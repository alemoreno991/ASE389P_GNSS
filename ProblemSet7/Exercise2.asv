clc; close all; clear all;
addpath('preprocessing')
addpath("acquisition")

%--------------------------------------------------------------------------
% --------------------    Load input signal     ---------------------------
% --------------------            &             ---------------------------
% -------------------- represent it in baseb-and ---------------------------
%--------------------------------------------------------------------------
filename = 'dfDataHead.bin';
fc = 1575.42e6;
Tfull   = 10;          % Time interval of data to load (1 ms = 1 data chip).
Fs      = 40e6/7;     % Sampling frequency (Hz).
bandpass.flag = true; % The file has the signal in bandpass representation
bandpass.fIF = 1.405396825396879e6; % Intermediate freq. of the bandpass

input = InputSignal(filename, Tfull, Fs, bandpass, 'high');
[tau, xVec, Ts, sMix] = input.getBasebandRepresentation();

%--------------------------------------------------------------------------
% --------------------         Acquisition      ---------------------------
%--------------------------------------------------------------------------
cfgAcquisition.method = 'FFT';
cfgAcquisition.fDVtr  = -5000:100:5000;
cfgAcquisition.nStep  = 1;
cfgAcquisition.nTc    = 10;
cfgAcquisition.nAccum = 2;

rcv = Acquisition(tau, xVec, Ts, cfgAcquisition);
for TXID = 14:14
    result{TXID} = rcv.acquireFine(tau, xVec, Ts, TXID, cfgAcquisition);
end

sigmaIQ = result{TXID}.sigmaIQ; % This is representative of the noise. (

%--------------------------------------------------------------------------
% --------------------          Tracking       ----------------------------
%--------------------------------------------------------------------------
% Get the bandpass representation of the input signal
[tVec, xVec, Ts, sMix] = input.getBandpassRepresentation();

% Configure the tracker
Nk = cfgTrack.nTc * cfgTrack.Tc *cfgTrack.Nc/Ts;

cfgTrack.fc     = fc;
cfgTrack.fIF    = bandpass.fIF;
cfgTrack.Ts     = Ts;
cfgTrack.Nc     = 1023;
cfgTrack.Tc     = 1e-3/cfgTrack.Nc;
cfgTrack.nTc    = 1;
cfgTrack.Ta     = Nk;
cfgTrack.sMix   = sMix;

cfgTrack.bufferSk.lenght = 100;
cfgTrack.sigmaIQ         = sigmaIQ;

cfgTrack.pll.Bn     = 10;
cfgTrack.pll.order  = 3;

cfgTrack.dll.Bn     = 0.1;


tracker = Tracker(result{TXID}, TXID, cfgTrack);
% Run the feedback tracking loop
theta_hat = [];
fDk_hat = [];
tsk_hat = [];
SkdB = [];
Sk = [];
t = [];

% Align the 0-th accumulation interval to the code to avoid data bit
% transition problems (At least when using 1ms intervals)
jk0 = floor(mod(result{TXID}.tsk_hat,1e-3)/cfgTrack.Ts);
while jk0 < length(xVec) - Nk
    jVeck = (floor(jk0):floor(jk0+Nk-1))';
    tVeck = jVeck*Ts;
    xVeck = xVec(jVeck+1); % Signal for the k-th accumulation interval
    track_result = tracker.update(tVeck, xVeck);

    % Save stuff for plotting
    fDk_hat = [fDk_hat track_result.fD_hat]; %#ok<*AGROW> 
    theta_hat = [theta_hat track_result.theta_hat];
    tsk_hat = [tsk_hat track_result.tsk_hat];
    SkdB = [SkdB track_result.SkdB];
    Sk = [Sk track_result.Sk];
    t = [t tVec(floor(jk0+Nk-1))];

    % Prepare for next index iteration
    jk0 = jk0 + Nk;
end

%% --------------------------- Plots ------------------------------------%%
close all

%------ |Sk|^2 
figure(1), clf
plot(t, SkdB, LineWidth=2)
title('$|Sk|^2$', Interpreter='latex')
xlabel('time [s]')
ylabel('$|Sk|^2$ [dB]', Interpreter='latex')
grid on;

%------ Sk 
figure(2), clf
scatter(real(Sk), imag(Sk))
title('Sk', Interpreter='latex')
xlabel('Real')
ylabel('Imag', Interpreter='latex')
grid on;
lims = [-3000 3000];
xlim(lims)
ylim(lims)

%------ Doppler 
figure(3), clf
plot(t, round(fDk_hat,2), LineWidth=2)
title('Doppler')
xlabel('time [s]')
ylabel('$\hat{f}_D$ [Hz]', Interpreter='latex')
grid on;

%------ Phase delay
figure(4), clf
plot(t, unwrap(theta_hat), LineWidth=2)
title('Phase delay')
xlabel('time [s]')
ylabel('$\hat{\theta}$ [deg]', Interpreter='latex')
grid on;

%------ Code delay 
figure(5), clf
plot(t, round(tsk_hat*1e6,2), LineWidth=2)
title('Code delay')
xlabel('time [s]')
ylabel('$\hat{t}_{sk}$ [us]', Interpreter='latex')
grid on;